<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="description" content="Hello! Welcome to my blog (*・ω・)ﾉ I will giv u free Cookies">
    <title>New 'Paint' program I made in Pygame</title>
    <link rel="stylesheet" href="blog.css">
    <link rel="stylesheet" href="pygments.css">
    <style>@import url('https://fonts.googleapis.com/css2?family=Josefin+Sans:wght@700&display=swap');</style> <!-- Google font "Josefin Sans" -->

    <!-- Latex stuff -->
    <script>
        MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
        };
    </script>
    <script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>

    <script>
        document.cookie = "freecookie=Heres your free cookie!!! Enjoy ~ヾ(・ω・);";
    </script>
</head>
<body>
    <a href="index.html"><img src="back.png" style="position: fixed; top: 20px; left: 20px;" /></a>
    <div class="entry">

        <div style="position: relative; width=0px; height=0px;">
            <img src="peek.gif" style="position: absolute; top:100px; left:-92px;" />
        </div>

        <h1>New 'Paint' program I made in Pygame</h1>

        <p class="date">July 22, 2023. 3:40pm</p>

        <p>It's been two weeks since I last touched this website :zonepeek:</p>

        <p>I've been working on a 'paint' program for my own personal use. I want a paint program that allows me lots of flexibility and precision. Something that allows me to use code for image manipulation on the fly, and something that allows me to do drawing through scripting.</p>

        <p>I really wanted to use Python for this since it has lots of convenient modules, so I settled on using Pygame. This is <i>probably</i> not the best engine to use... (⌒_⌒;) It's just the one I'm most familiar with. The main library I use for image manipulation is PIL.</p>

        <p>Here is what it looks like right now, there's not much:</p>

        <center>
            <img src="paint/paint-1.png" width="50%"/>
        </center>

        <p>Currently, it has a Layers system, a color picker, and some tools. The most useful feature I have here so far is the background removal tool. Basically, it allows you to click on an area on an image and make it transparent. <span style="color:rgb(255,128,255); font-style:italic">(Hover on the images to make it easier to see.)</span></p>

        <center>
            <img src="paint/paint-2.png" width="33%" class="image" />
        </center>

        <p>The algorithm is more complicated than it seems. I have to account for anti-aliased edges so I don't get weird gray pixels around the edge. Look at the image below to see what I mean.</p>

        <center>
            <img src="paint/paint-3.png" width="25%" class="image" />
        </center>

        <p>The first one is the original image. The second one simply changes the alpha values of each pixel depending on how 'white' that pixel is. This leaves some pixels gray-colored, which is bad. The third one fixes this by changing the RGB value of the pixel to also match its surroundings.</p>

        <p>There's one issue with this approach. The image I showed above is very simple; there's only a single black object on a white background, so we can easily just set all RGB values as black and be done. Unfortunately, most images aren't so simple. Consider for example,</p>

        <center>
            <img src="paint/paint-4.png" width="50%" class="image" />
        </center>

        <p>The original image contains three objects: a black one, a gray one, and a light gray one. We expect the background removal tool to give the image on the right. How would we determine the RGB values for each pixel in this image?</p>

        <center>
            <img src="paint/paint-5.png" width="33%" />
        </center>

        <p>These two pixels here have the exact same RGB value. Yet, we want to set them to different alpha values since they belong to shapes of different color. We have to somehow tell that the top one belongs to the 'gray' shape, and the bottom one belongs to the 'black' shape. Even worse, how would we handle pixels in the intersection?</p>

        <center>
            <img src="paint/paint-6.png" width="33%" />
        </center>

        <p>It would need to somehow take the color from the "solid" portion of the image.</p>

        <p>An idea that popped up to me was to use a <i>Voronoi-esque</i> diagram. Essentially, we only take the "solid" portion of the image, and spread the colors to the entire image. This way, a pixel will take the RGB value of the nearest 'solid' pixel it finds.</p>

        <center>
            <img src="paint/paint-7.png" width="50%" />
        </center>

        <p>Using this idea, the algorithm would be:</p>

        <ol>
            <li>Use BFS to figure out which pixels belong the background, up to some tolerance.</li>
            <li>Generate Voronoi-esque thing to spread out the colors from the remaining pixels.</li>
            <li>Calculate the alpha mask for each pixel in the background.</li>
        </ol>

        <p>Each step in this algorithm takes $O(w\cdot h)$ time, which should be fast. I could make it even faster by only applying the Voronoi step to the pixels around the border of the object.</p>

        <p>This a lot of steps to implement, so I tested it out with a grayscale image first. It worked surprisingly better than I expected! :ikuwow:</p>

        <center>
            <img src="paint/paint-8.png" width="75%" class="image" />

            <p><b>Left image:</b> original; &nbsp; &nbsp; &nbsp; <b>Middle image:</b> "Voronoi" version; &nbsp; &nbsp; &nbsp; <b>Right image:</b> Final output</p>
        </center>

        <p>The final output has a couple of issues. When you zoom in on the image, you can see some of the "Voronoi" artifacts. It should be easily fixable by adjusting the threshold. After a couple of tweaks and making it work for RGB, here is the result I got:</p>

        <center>
            <img src="paint/paint-9.png" width="50%" class="image" />
        </center>

        <p>I think I'm satisfied with this result. It still feels pretty trial-and-error-y to find the perfect threshold for the tool. All that's left for me to implement for this tol is a slider to easily change the threshold and feather radius.</p>

        <p>I still have a couple features I want to implement:</p>
        <ul>
            <li><b>Sliders for adjusting brush size, bucket threshold, etc.</b> Maybe they could all be the same slider since I don't really plan on implementing many tools.</li>
            <li><b>Blending options and layer merging.</b> I tried this once but it seems pretty slow for large images, I should find a way to optimize this.</li>
            <li><b>Scripting for draw tools.</b> For example, I want to be able to type something like this to quickly draw a grid:<br />

            <div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">draw_line</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">draw_line</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>

            <li><b>Image filters,</b> such as adjusting the vibrance of an image. I still don't know how exactly my phone's image editor does this.
        </ul>

        <p>I think that's all the features I would need. Right now, I can use the background removal tool to quickly turn any image I want to Discord emojis. :pomihappy:</p>

    </div>
</body>
<script src="../emojis/script.js"></script>
